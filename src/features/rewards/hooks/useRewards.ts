import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { UUID } from '../../../shared/types/common';
import { rewardsApi } from '../api/rewardsApi';
import {
  Reward,
  RewardEligibilityResponse,
  RewardApplyInput,
  rewardKeys,
} from '../types';
import {
  QUERY_STALE_TIMES,
  QUERY_CACHE_TIMES,
  RETRY_CONFIG,
} from '../constants/rewardConstants';
import { validateRewardApplyInput } from '../utils/rewardHelpers';

/**
 * Hook to calculate eligibility for a subscription
 * 
 * @param subscriptionId - Subscription ID to check eligibility for
 * @param enabled - Whether the query should run (default: true)
 * @returns Query result with eligibility data
 */
export const useRewardEligibility = (
  subscriptionId: string | undefined,
  enabled = true
) => {
  return useQuery({
    queryKey: rewardKeys.eligibility(subscriptionId || ''),
    queryFn: () => rewardsApi.calculateEligibility(subscriptionId!),
    enabled: enabled && !!subscriptionId,
    staleTime: QUERY_STALE_TIMES.eligibility,
    gcTime: QUERY_CACHE_TIMES.eligibility,
    retry: RETRY_CONFIG.retries,
    retryDelay: RETRY_CONFIG.retryDelay,
    refetchOnWindowFocus: false,
  });
};

/**
 * Hook to get available rewards for a client
 * Returns rewards with status='pending' that haven't expired
 * 
 * @param clientId - Client ID to get rewards for
 * @returns Query result with available rewards array
 */
export const useAvailableRewards = (clientId: UUID | undefined) => {
  return useQuery({
    queryKey: rewardKeys.available(clientId || ''),
    queryFn: () => rewardsApi.getAvailableRewards(clientId!),
    enabled: !!clientId,
    staleTime: QUERY_STALE_TIMES.rewards,
    gcTime: QUERY_CACHE_TIMES.rewards,
    retry: RETRY_CONFIG.retries,
    retryDelay: RETRY_CONFIG.retryDelay,
    refetchOnWindowFocus: false,
  });
};

/**
 * Hook to get all rewards for a subscription
 * Returns all rewards (pending, applied, expired) generated by a subscription
 * 
 * @param subscriptionId - Subscription ID to get rewards for
 * @returns Query result with rewards array
 */
export const useRewardsBySubscription = (subscriptionId: string | undefined) => {
  return useQuery({
    queryKey: rewardKeys.bySubscription(subscriptionId || ''),
    queryFn: () => rewardsApi.getRewardsBySubscription(subscriptionId!),
    enabled: !!subscriptionId,
    staleTime: QUERY_STALE_TIMES.rewards,
    gcTime: QUERY_CACHE_TIMES.rewards,
    retry: RETRY_CONFIG.retries,
    retryDelay: RETRY_CONFIG.retryDelay,
    refetchOnWindowFocus: false,
  });
};

/**
 * Hook to calculate reward eligibility (mutation)
 * Used for standard eligibility calculation after subscription cycle ends
 */
export const useCalculateRewardEligibility = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (subscriptionId: string) => {
      console.log('Calculating reward eligibility:', subscriptionId);
      return rewardsApi.calculateEligibility(subscriptionId);
    },
    onSuccess: (data, subscriptionId) => {
      console.log('Reward eligibility calculated:', {
        subscriptionId,
        eligible: data.eligible,
        attendanceCount: data.attendance_count,
        rewardId: data.reward_id,
      });

      // Invalidate eligibility query
      queryClient.invalidateQueries({
        queryKey: rewardKeys.eligibility(subscriptionId),
      });

      // If reward was created, invalidate available rewards
      if (data.eligible && data.reward_id) {
        queryClient.invalidateQueries({
          queryKey: rewardKeys.lists(),
        });
        
        // Also invalidate rewards by subscription
        queryClient.invalidateQueries({
          queryKey: rewardKeys.bySubscription(subscriptionId),
        });
      }
    },
    onError: (error, subscriptionId) => {
      console.error('Error calculating reward eligibility:', {
        error,
        errorMessage: error instanceof Error ? error.message : 'Error desconocido',
        subscriptionId,
      });
    },
  });
};

/**
 * Hook to calculate reward eligibility for renewal
 * This allows calculating rewards even if the subscription hasn't ended yet
 * Used when renewing a subscription early with 20+ attendances
 * 
 * Note: Uses the same backend endpoint, but the backend should handle the logic
 * for active subscriptions. If backend doesn't support it, a new endpoint may be needed.
 */
export const useCalculateRewardEligibilityForRenewal = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (subscriptionId: string) => {
      console.log('Calculating reward eligibility for renewal:', subscriptionId);
      return rewardsApi.calculateEligibility(subscriptionId);
    },
    onSuccess: (data, subscriptionId) => {
      console.log('Reward eligibility calculated for renewal:', {
        subscriptionId,
        eligible: data.eligible,
        attendanceCount: data.attendance_count,
        rewardId: data.reward_id,
      });

      // Invalidate eligibility query
      queryClient.invalidateQueries({
        queryKey: rewardKeys.eligibility(subscriptionId),
      });

      // If reward was created, invalidate all reward-related queries
      if (data.eligible && data.reward_id) {
        // Invalidate available rewards (will be refreshed when needed)
        queryClient.invalidateQueries({
          queryKey: rewardKeys.lists(),
        });
        
        // Invalidate rewards by subscription
        queryClient.invalidateQueries({
          queryKey: rewardKeys.bySubscription(subscriptionId),
        });
      }
    },
    onError: (error, subscriptionId) => {
      console.error('Error calculating reward eligibility for renewal:', {
        error,
        errorMessage: error instanceof Error ? error.message : 'Error desconocido',
        subscriptionId,
      });
    },
  });
};

/**
 * Hook to apply a reward to a subscription
 * Marks the reward as applied and associates it with the subscription
 * 
 * @returns Mutation function to apply a reward
 */
export const useApplyReward = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ rewardId, data }: { rewardId: string; data: RewardApplyInput }) => {
      // Validate inputs using shared helper
      validateRewardApplyInput(rewardId, data);

      console.log('Applying reward via API:', {
        rewardId,
        subscriptionId: data.subscription_id,
        discountPercentage: data.discount_percentage,
      });

      return rewardsApi.applyReward(rewardId, data);
    },
    onSuccess: (data, variables) => {
      console.log('Reward applied successfully:', {
        rewardId: variables.rewardId,
        subscriptionId: variables.data.subscription_id,
        appliedReward: data,
      });

      const { subscription_id: subscriptionId } = variables.data;

      // Invalidate reward-related queries
      queryClient.invalidateQueries({
        queryKey: rewardKeys.all,
      });

      // Invalidate specific subscription rewards
      queryClient.invalidateQueries({
        queryKey: rewardKeys.bySubscription(subscriptionId),
      });

      // Invalidate subscriptions to update pricing (more granular)
      queryClient.invalidateQueries({
        queryKey: ['subscriptions'],
      });

      // Invalidate clients to refresh dashboard data
      queryClient.invalidateQueries({
        queryKey: ['clients'],
      });
    },
    onError: (error, variables) => {
      console.error('Error in applyReward mutation:', {
        error,
        errorMessage: error instanceof Error ? error.message : 'Error desconocido',
        rewardId: variables.rewardId,
        subscriptionId: variables.data.subscription_id,
        discountPercentage: variables.data.discount_percentage,
      });
    },
  });
};

